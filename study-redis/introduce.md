Redis
参考文章：
https://www.cnblogs.com/baichunyu/p/11631660.html

https://www.cnblogs.com/coolops/p/12809893.html

https://www.cnblogs.com/gunduzi/p/13160448.html
**1：为什么使用redis而不用map、guave做缓存？**
```text
缓存分为本地缓存和分布式缓存，java自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁二结束，并且在多实例的情况下，每个实例都需要
各自保存一份缓存，缓存不具有一致性；
使用redis或者memcached之类的称之为分布式缓存，在多实例的情况下，各实例公用一份缓存数据，缓存具有一致性，缺点是需要保持redis或memcached服务的高可用，整个架构上较为复杂。
```
**2：redis和memcached的区别**
```text

1.1 redis支持更丰富的数据类型，：Redis不仅仅支持简单的key、value类型的数据，同时还提供lis、set、zset、hash等数据结构的存储，memcached支持简单的数据类型 string
1.2 redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载镜像使用，而mamcache吧数据全部存在内存之中
1.3 集群模式：memcached没有原生的的集群模式，需要依靠客户端来实现集群中的分片写入数据，但是redis目前是原生支持cluster模式的
1.4 memcached是多线程，非阻塞IO复用的网络模型，Redis使用单线程的多路IO复用模型

```
3:redis常见数据结构以及使用场景分析
```text
1.1 String
  常用命令：set/get/deci/incr/mget等
  String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。
1.2.Hash
　　常用命令： hget,hset,hgetall 等。
　　hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。.
比如下面我就用 hash 类型存放了我本人的一些信息：
key=JavaUser293847 
value={  
       “id”: 1,  
       “name”: “SnailClimb”,  
       “age”: 22,  
        “location”: “Wuhan, Hubei”
         }
1.3.List  
　　常用命令: lpush,rpush,lpop,rpop,lrange等  
　　list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。  
　　Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。  
　　另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，
基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。
1.4.Set  
　　常用命令： sadd,spop,smembers,sunion 等  
　　set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。  
　　当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。  
　　比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：
   sinterstore key1 key2 key3     将交集存在key1内
1.5.Sorted Set  
  　　常用命令： zadd,zrange,zrem,zcard等  
  　　和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。 

```
4：redis设置过期时间
作为一个缓存数据库，这个是非常使用的使用的；
例子：如果在项目中使用token或者一些登录信息，尤其是短信验证码都是有时间限制的，传统的数据库处理方式，一般都是自己判断过期，这样会影响性能
使用redis后，可以给 expire time 这就是过期时间；
5：redis事务

6：缓存雪崩和缓存穿透问题
1.1缓存雪崩（redis因扛不住并发量而宕机，请求瞬间到数据库）
缓存同一时间大面积的失效，所以，后面的请求都会落在数据库上，造成数据库短时间内承受大量请求而崩溃
解决方案：
   事前：尽量保证整个redis集群的高可用性，发现机器宕机尽快补上，选择合适的内存淘汰策略
   事中：本地ehcache缓存+hystrix限流降级，避免musql崩掉
   事后：利用redis持久化机制保存的数据尽快恢复缓存
用户发送给一个请求，系统A收到请求后，先查本地ehcache缓存，如果没查到再查redis。如果ehcache和redis都没有
再查数据库，将数据库中的结果，写入ehcache和redis中
限流组件，可以设置每秒的请求，有多少能通过组件，剩余未通过的请求，走降级，可以返回默认值或友情提示
1.2：缓存穿透（Redis服务正常，过多的请求全部落在数据库中，导致数据库崩溃）
一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到了数据库上，造成数据库短时间内承受大量请求而崩溃
解决办法：
每次系统A从数据库中只要没查到，就写一个空值到魂村里去，比如set -999 UNKNOWN。然后设置一个过期时间，这样的话，
下次有相同的key访问的时候，在缓存失效之前，都可以直接从缓存中读数据
1.3 缓存击穿（Redis服务正常，当key值失效时，过多的请求落在数据库，导致崩溃）
缓存击穿，就是说某个key非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个key在失效的瞬间，
大量的请求就击穿了缓存，直接请求数据库，就像在一道避障上凿开了一个洞。
解决方法:
可以将热点数据设置为永远不过期；或者基于 redis or zookeeper实现互斥锁，等待第一个请求构建完。
缓存之后，在释放锁，进而其他请求才能通过该key访问。
 1.4 集群脑裂（通过拒绝client数据请求，减少数据存入之前的master节点中，来介绍数据的丢失）
   集群中出现两个master，主要原因在于master节点的网络出现问题，master和集群中的slave、sentinel通信出现了问题
   由于sentinel连接不上master。就会在slave中选择出一个master，这时候如果client没有来得及切换，就会把数据写入到原来的master中，
   一旦网络恢复，原来的master变为slave，从新的master上复制数据，那么之前client向原来master上写的数据就会丢失了
解决方法：
   在redis配置文件中添加
   min-slavers-to-writer 3
   min-slavers-max-lag 10
   第一个参数表示最少的salve节点为3个，第二个参数表示数据复制和同步的延迟不能超过10秒
   配置了这两个参数，如果发生脑裂，原master会在客户端写入操作的时候会拒绝，这样可以避免大量数据丢失
7：Redis集群搭建的三种方法
一：主从模式
1.1Redis主从原理
redis对染读取写入的速度非常快，但是也会产生性能的瓶颈，特别是读压力上，为了分担压力，Redis支持主从复制
Redis的主从结构一主一从，一主多从或级联结构，复制类型可以根据是否是全量而分为全量同步或增量同步
1.1.1全量同步
Redis全量复制一般发生在slave的初始阶段，这是slave需要将master上的数据都复制一份，
1.1.2增量复制
增量复制实际上就是在slave初始化完成后开始正常工作时master发生写操作同步到slave的过程
增量复制的过程主要是master每执行一个写命令就像slave发送相同的写命令，slave接受并执行写命令，从而保持主从一致
1.1.3 部分复制
当主节点网络中断后，从节点再次连上主节点时会发送psync{offset}{runid}命令请求部分复制，也就是发送一个偏移量码告诉主节点删词复制在哪里
1.2Redis主从同步的策略
主从同步刚链接的时候进行全量同步，全量同步结束后开始增量同步，如果有需要，slave在任何时候
都可以发起全量同步，其主要策略就是无论如何首先会尝试进行增量同步，如果不成功，则会要求slace进行全量同步，之后再增量同步
1.3Redis的主从同步特点
（1）采用异步复制
（2）可以一主多从
（3）主从复制对于master来说是非阻塞的，也就是说slave在进行主从复制的过程中，master依然可以处理请求
（4）组从复制对于slave来说也是非阻塞的，也就是说slave在复制的过程中可以接受外界的查询，只不过数据返回的不一定
正确，为了避免这个情况，可以在slave的配置文件中配置，在同步过程中阻止查询
（5）每个slave可以接受来自其他slave的链接
（6）主从复制提高了Redis服务的扩展性，避免单节点问题，另外也为数据备份冗余提供了解决方案

二：Redis哨兵
2.1Reds哨兵机制
在主从复制实现之后，如果想对master进行监控，Redis提供了一种哨兵机制，哨兵的含义就是监控Redis系统的运行状态，并做相应的响应
2.1.1哨兵功能
（1）监控所有redis节点是否正常运行
（2）master故障后可以通过投票即止，从slave中选举出新的master，保证集群正常运行
2.1.2哨兵的任务
哨兵主要用于管理多个redis服务器，主要有一下三个任务
（1）监控；哨兵会不断的检测master和slave之间是否运行正常
（2）提醒；当监控的某个Redis出现问题，哨兵可以通过API想管理员或者其他引用程序发送通知
（3）故障迁移：当一个master不能正常工作时，哨兵会开始一次自动故障迁移操作，他会将失效的master的
其中一个slave提升为master，并让失效的master和其他slave改为复制新的master，当客户端试图
链接失效的master是，集群也会想客户端返回新的master地址，使得集群可以使用新的master代替失效的master
2.2Redis哨兵的工作原理
* 每个Sentinel进程以每秒钟一次的频率向整个集群的master主服务器，slave从服务器以及其他sentinel进程发送一个ping命令
* 如果一个实例（instance）距离最后一次有效回复ping命令的时间超过down-after-milliseconds选项所设定的值
  则这个实例会被sentinel进行标记为主观下线
* 如果一个master主服务器被标记为主观下线，则正在监视这个master主服务的所有sentinel进程要以每秒一次的频率确认master主服务的确进入了主观下线状态
* 当有足够数量的sentinel进程在指定的时间范围内确认master主服务进入了主观下线状态，则master会被标记为客观下线
* 在一般情况下，每个sentinel进程会以每10秒一次的频率想集群中的所有master主服务器、slave服务器发送info命令
* 当master主服务器被sentinel进程标记为客观下线是，sentinel进程向下线的master主服务器的所有slave从服务器发送info命令的频率从10改为1
* 如果没有足够数量的sentinel进程同一master下线，则master的客观下线状态会被移除
  如果master重新向sentinel进程发送ping命令返回有效值回复，master主服务器的主观下线状态移除

2.2.2 故障迁移
首先是从主服务器的从服务器中选出一个从服务器作为新的主服务器。选点的依据依次是：网络连接正常->5秒内回复过INFO命令->10*down-after-milliseconds内与主连接过的->从服务器优先级->复制偏移量->运行id较小的。选出之后通过slaveif no ont将该从服务器升为新主服务器。
其次通过slaveof ip port命令让其他从服务器复制该信主服务器。
最后当旧主重新连接后将其变为新主的从服务器。注意如果客户端与就主服务器分隔在一起，写入的数据在恢复后由于旧主会复制新主的数据会造成数据丢失。
故障转移成功后会通过发布订阅连接广播新的配置信息，其他sentinel收到后依据配置纪元更大来更新主服务器信息。Sentinel保证第二个活性属性：一个可以相互通信的Sentinel集合会统一到一个拥有更高版本号的相同配置上。    
* 选主过程
第一步：选择replica-priority配置项中个，参数越小，表示优先级越高
第二步：优先级相同，选择offset最大的，offset表示主节点向从节点同步数据的偏移量，越大表示同步的数据越多
第三步：如果offet相同，则选择run id小的
* 后续事情
1：sentinel会向别的salve发送salveof命令，告诉他们master是谁
2：如果之前的master重新上线时，sentinel同样会发起salveof命令，将其变成从节点

2.2.3 缺点
（1）、主从服务器的数据要经常进行主从复制，这样会造成性能下降；
（2）、当主服务器宕机后，从服务器切换成主服务器的那段时间，服务是不可用的。



































